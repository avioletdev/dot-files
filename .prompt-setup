# Avery's Modular ZSH Prompt
# Lightweight, modular, and performant

# Enable command substitution
setopt PROMPT_SUBST

# Source modules relative to this script
ZSH_CONFIG_DIR="${0:A:h}/zsh"
source "${ZSH_CONFIG_DIR}/theme.zsh"
source "${ZSH_CONFIG_DIR}/utils.zsh"
source "${ZSH_CONFIG_DIR}/git.zsh"
source "${ZSH_CONFIG_DIR}/env.zsh"
source "${ZSH_CONFIG_DIR}/nav.zsh"

# Initialize zoxide (if installed)
if command -v zoxide &> /dev/null; then
    eval "$(zoxide init zsh)"
fi

# System & Font Health Check
function check_zsh_prompt_setup() {
    local error_count=0
    
    # 1. Locale check
    if [[ ! "$LANG" == *".UTF-8"* ]] && [[ ! "$LC_ALL" == *".UTF-8"* ]]; then
        echo -e "\n\033[1;31m[!] Environment Error: Your locale is not UTF-8.\033[0m"
        echo "    Nerd Fonts require a UTF-8 environment (e.g., LANG=en_US.UTF-8)."
        error_count=$((error_count + 1))
    fi

    # 2. Dependency Check
    local deps=("zoxide" "fzf")
    local missing_deps=()
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing_deps+=("$dep")
        fi
    done

    # 3. Welcome Message & Visual Check
    echo -e "\n\033[1;34mâœ¨ Avery's Modular Zsh Prompt\033[0m"
    echo -e "\033[1;90mIcons    :\033[0m $symbol_list[heart] $symbol_list[git] $symbol_list[clock] $symbol_list[node] \033[0;32m(If icons look correct, you're all set!)\033[0m"
    echo -e "\033[1;90mLigatures:\033[0m Test: |>  ->  => \033[0;32m(If these join, ligatures are active!)\033[0m"
    echo -e "\033[1;90mNote:\033[0m If ligatures don't join, enable 'Font Ligatures' in your terminal settings."
    
    echo -e "\n\033[1;34mðŸš€ Navigation Commands:\033[0m"
    echo -e "\033[0;96mcr [query]\033[0m  Fuzzy switch to any repo in ~/repos"
    echo -e "\033[0;96mfh\033[0m          Fuzzy search command history"
    echo -e "\033[0;96mz [dir]\033[0m       Smart jump using zoxide"

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        echo -e "\n\033[1;33m[!] Missing Dependencies:\033[0m ${missing_deps[*]}"
        echo -e "Install them via Homebrew: \033[0;96mbrew install ${missing_deps[*]}\033[0m"
    fi

    echo -e "\n\033[1;33m,___,"
    echo -e "(0,0)"
    echo -e "/)  ) ---*ï½¥ï½¡ï¾Ÿ \033[1;36mâœ¨ I cast pretty shell!\033[0m"
    echo -e "\033[1;33m-\"-\"-"
    
    echo -e "\n\033[1;90mTo hide this welcome message, add this to your .zshrc:\033[0m"
    echo -e "\033[0;96mexport ZSH_PROMPT_SKIP_CHECK=1\033[0m\n"
}

# Run check only once per session, and allow permanent skip
if [[ -z "$ZSH_PROMPT_CHECKED" ]] && [[ -z "$ZSH_PROMPT_SKIP_CHECK" ]]; then
    check_zsh_prompt_setup
    export ZSH_PROMPT_CHECKED=1
fi

function build_info_line() {
    local -a segment_contents
    local -a segment_colors
    local basedir=$(basename "$(pwd)")
    local pathInfo=$(path_info)

    # 1. Collect segments and colors
    segment_colors+=("${prompt_colors[one]}")
    segment_contents+=("%n")
    
    segment_colors+=("${prompt_colors[two]}")
    segment_contents+=("$pathInfo")

    if is_git_repo ; then
        segment_colors+=("${prompt_colors[three]}")
        segment_contents+=("$(git_info)")
        
        if [[ "$basedir" != "$pathInfo" ]] ; then
            segment_colors+=("${prompt_colors[four]}")
            segment_contents+=("$(get_project_subfolder 6 "$pathInfo")")
        fi
    fi

    local env_info=$(project_info)
    if [[ -n "$env_info" ]]; then
        segment_colors+=("${prompt_colors[five]}")
        segment_contents+=("$env_info")
    fi

    # 2. Render with lookahead for seamless "handshake" transitions
    local res=""
    local i
    local num_segments=$#segment_contents
    for i in {1..$num_segments}; do
        local is_start="false"
        [[ $i -eq 1 ]] && is_start="true"
        
        local next_color=""
        [[ $i -lt $num_segments ]] && next_color="${segment_colors[$((i+1))]}"
        
        res+="$(render_segment "$is_start" "${segment_colors[$i]}" "${segment_contents[$i]}" "$next_color")"
    done

    echo -n "$res"
}

# Hooks
preexec() {
    timer_start
}

precmd() {
    local last_status=$?
    # Determine heart color based on last command status
    local heart_color="${prompt_colors[six]}"
    [[ $last_status -ne 0 ]] && heart_color="${prompt_colors[red]}"

    # Command Duration
    local duration=$(timer_stop)
    local timer_str=""
    [[ -n "$duration" ]] && timer_str=" | $duration"

    # Build the info line once per prompt
    INFO_LINE=$(build_info_line)
    
    # Assembly PROMPT
    PROMPT="%k%F{${heart_color}}${symbol_list[round_left]}%K{${heart_color}}%F{${prompt_colors[white]}} ${symbol_list[heart]} $(date '+%H:%M')$timer_str %k%F{${heart_color}}${symbol_list[round_right]} %f|> "
    
    print -P "\n${INFO_LINE}\n"
}
