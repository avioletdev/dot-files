# Avery's Modular ZSH Prompt
# Lightweight, modular, and performant

# Guard: Ensure we are in Zsh
if [ -z "$ZSH_VERSION" ]; then
    echo "Error: This prompt configuration requires Zsh."
    return 1 2>/dev/null || exit 1
fi

# Enable command substitution
setopt PROMPT_SUBST

# Source modules relative to this script
# We use the absolute path of the directory containing this script.
# ${(%):-%x} is the most robust way in Zsh to get the current script's path when sourced.
ZSH_CONFIG_DIR="${${(%):-%x}:A:h}/zsh"

source "${ZSH_CONFIG_DIR}/theme.zsh"
source "${ZSH_CONFIG_DIR}/utils.zsh"
source "${ZSH_CONFIG_DIR}/git.zsh"
source "${ZSH_CONFIG_DIR}/env.zsh"
source "${ZSH_CONFIG_DIR}/nav.zsh"

# Initialize zoxide (if installed)
if command -v zoxide &> /dev/null; then
    eval "$(zoxide init zsh)"
fi

# System & Font Health Check
function check_zsh_prompt_setup() {
    local error_count=0
    
    # 1. Locale check
    if [[ ! "$LANG" == *".UTF-8"* ]] && [[ ! "$LC_ALL" == *".UTF-8"* ]]; then
        echo -e "\n\033[1;31m[!] Environment Error: Your locale is not UTF-8.\033[0m"
        echo "    Nerd Fonts require a UTF-8 environment (e.g., LANG=en_US.UTF-8)."
        error_count=$((error_count + 1))
    fi

    # 2. Dependency Check
    local deps=("zoxide" "fzf")
    local missing_deps=()
    local common_paths=("/opt/homebrew/bin" "/usr/local/bin" "/usr/bin" "/bin")
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            # If not in PATH, check common locations directly
            local found="false"
            for p in "${common_paths[@]}"; do
                if [[ -x "$p/$dep" ]]; then
                    found="true"
                    break
                fi
            done
            [[ "$found" == "false" ]] && missing_deps+=("$dep")
        fi
    done

    # 3. Welcome Message & Visual Check
    echo -e "\n\033[1;34mâœ¨ Avery's Modular Zsh Prompt\033[0m"
    printf "\033[1;90m%-12s\033[0m %s \033[0;32m(If icons look correct, you're all set!)\033[0m\n" "Icons:" "$symbol_list[heart]|$symbol_list[git]|$symbol_list[clock]|$symbol_list[node]"
    printf "\033[1;90m%-12s\033[0m %s \033[0;32m(If these join, ligatures are active!)\033[0m\n" "Ligatures:" "|> -> =>"
    
    echo -e "\n\033[1;34mðŸš€ Navigation Commands:\033[0m"
    printf "\033[0;96m%-12s\033[0m %s\n" "cr [query]" "Fuzzy switch to any repo in ~/repos"
    printf "\033[0;96m%-12s\033[0m %s\n" "fh"         "Fuzzy search command history"
    printf "\033[0;96m%-12s\033[0m %s\n" "z [dir]"    "Smart jump using zoxide"
    echo -e "             \033[0;90m(Tip: cd into a folder once to 'teach' zoxide about it!)\033[0m"

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        echo -e "\n\033[1;33m[!] Missing Dependencies:\033[0m ${missing_deps[*]}"
        printf "\033[1;90m%-12s\033[0m \033[0;96mbrew install %s\033[0m\n" "Install:" "${missing_deps[*]}"
    fi

    echo -e "\n\033[1;33m,___,"
    echo -e "(0,0)"
    echo -e "/)  ) ---*ï½¥ï½¡ï¾Ÿ \033[1;36mâœ¨ I cast pretty shell!\033[0m"
    echo -e "\033[1;33m-\"-\"-"
    
    echo -e "\n\033[1;90mTo hide this welcome message, add this to your .zshrc:\033[0m"
    echo -e "\033[0;96mexport ZSH_PROMPT_SKIP_CHECK=1\033[0m\n"
}

# Run check only once per session, and allow permanent skip
if [[ -z "$ZSH_PROMPT_CHECKED" ]] && [[ -z "$ZSH_PROMPT_SKIP_CHECK" ]]; then
    check_zsh_prompt_setup
    export ZSH_PROMPT_CHECKED=1
fi

function build_info_line() {
    local -a segment_contents
    local -a segment_colors
    local -a segment_links
    local basedir=$(basename "$(pwd)")
    local pathInfo=$(path_info)

    # 1. Collect segments, colors and links
    if is_git_repo; then
        # Inside a repo: Repo first, NO username
        local git_root_path=$(get_git_toplevel)
        segment_colors+=("${prompt_colors[one]}")
        segment_contents+=("${symbol_list[git]} $(get_git_root)")
        segment_links+=("")

        segment_colors+=("${prompt_colors[two]}")
        segment_contents+=("$(git_info)")
        segment_links+=("")

        local breadcrumb=$(get_breadcrumb_info)
        if [[ "$breadcrumb" -gt 0 ]]; then
            segment_colors+=("${prompt_colors[three]}")
            segment_contents+=("$breadcrumb ${symbol_list[folder]}")
            segment_links+=("")
            
            segment_colors+=("${prompt_colors[four]}")
            segment_contents+=("$(get_current_leaf)")
            segment_links+=("file://${PWD}")
        else
            # Show project icons (Node, Python, etc.) at the repo root
            local env_info=$(project_info)
            if [[ -n "$env_info" ]]; then
                segment_colors+=("${prompt_colors[three]}")
                segment_contents+=("$env_info")
                segment_links+=("")
            fi
        fi
    else
        # Normal flow: Username first
        segment_colors+=("${prompt_colors[one]}")
        segment_contents+=("%n")
        segment_links+=("")
        
        segment_colors+=("${prompt_colors[two]}")
        segment_contents+=("$pathInfo")
        segment_links+=("")

        local env_info=$(project_info)
        if [[ -n "$env_info" ]]; then
            segment_colors+=("${prompt_colors[three]}")
            segment_contents+=("$env_info")
            segment_links+=("")
        fi
    fi

    # 2. Render with lookahead for seamless "handshake" transitions
    local res=""
    local i
    local num_segments=$#segment_contents
    for i in {1..$num_segments}; do
        local is_start="false"
        [[ $i -eq 1 ]] && is_start="true"
        
        local next_color=""
        [[ $i -lt $num_segments ]] && next_color="${segment_colors[$((i+1))]}"
        
        res+="$(render_segment "$is_start" "${segment_colors[$i]}" "${segment_contents[$i]}" "$next_color" "${prompt_colors[white]}" "${segment_links[$i]}")"
    done

    echo -n "$res"
}

# Hooks
_prompt_preexec() {
    timer_start
}

_prompt_precmd() {
    local last_status=$?
    # Determine heart color based on last command status
    local heart_color="${prompt_colors[six]}"
    [[ $last_status -ne 0 ]] && heart_color="${prompt_colors[red]}"

    # Command Duration
    local duration=$(timer_stop)
    local timer_str=""
    [[ -n "$duration" ]] && timer_str=" | $duration"

    # Build the info line once per prompt
    INFO_LINE=$(build_info_line)
    
    # Assembly PROMPT
    PROMPT="%k%F{${heart_color}}${symbol_list[round_left]}%K{${heart_color}}%F{${prompt_colors[white]}} ${symbol_list[heart]} $(date '+%H:%M')$timer_str %k%F{${heart_color}}${symbol_list[round_right]} %f|> "
    
    print -P "\n${INFO_LINE}\n"
}

# Add hooks to the Zsh hook arrays (Modern Zsh Standard)
# This ensures we don't conflict with zoxide or other plugins
autoload -Uz add-zsh-hook
add-zsh-hook preexec _prompt_preexec
add-zsh-hook precmd _prompt_precmd
